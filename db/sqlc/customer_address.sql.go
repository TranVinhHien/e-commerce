// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: customer_address.sql

package db

import (
	"context"
	"database/sql"
)

const createCustomerAddress = `-- name: CreateCustomerAddress :exec
INSERT INTO customer_address (
  id_address, customer_id, address, phone_number
) VALUES (
  ?, ?, ?, ?
)
`

type CreateCustomerAddressParams struct {
	IDAddress   string `json:"id_address"`
	CustomerID  string `json:"customer_id"`
	Address     string `json:"address"`
	PhoneNumber string `json:"phone_number"`
}

func (q *Queries) CreateCustomerAddress(ctx context.Context, arg CreateCustomerAddressParams) error {
	_, err := q.db.ExecContext(ctx, createCustomerAddress,
		arg.IDAddress,
		arg.CustomerID,
		arg.Address,
		arg.PhoneNumber,
	)
	return err
}

const deleteCustomerAddress = `-- name: DeleteCustomerAddress :exec
DELETE FROM customer_address
WHERE id_address = ?
`

func (q *Queries) DeleteCustomerAddress(ctx context.Context, idAddress string) error {
	_, err := q.db.ExecContext(ctx, deleteCustomerAddress, idAddress)
	return err
}

const getCustomerAddress = `-- name: GetCustomerAddress :one
SELECT id_address, customer_id, address, phone_number, create_date, update_date FROM customer_address
WHERE id_address =  ? LIMIT 1
`

func (q *Queries) GetCustomerAddress(ctx context.Context, idAddress string) (CustomerAddress, error) {
	row := q.db.QueryRowContext(ctx, getCustomerAddress, idAddress)
	var i CustomerAddress
	err := row.Scan(
		&i.IDAddress,
		&i.CustomerID,
		&i.Address,
		&i.PhoneNumber,
		&i.CreateDate,
		&i.UpdateDate,
	)
	return i, err
}

const getCustomerAddressByAddressAndCustomer = `-- name: GetCustomerAddressByAddressAndCustomer :one
SELECT customer_address.id_address, customer_address.customer_id, customer_address.address, customer_address.phone_number, customer_address.create_date, customer_address.update_date,customers.customer_id, customers.name, customers.email, customers.image, customers.dob, customers.gender, customers.account_id, customers.create_date, customers.update_date, customers.device_registration_token FROM customer_address join  customers ON  customers.customer_id = customer_address.customer_id
WHERE customer_address.id_address = ? AND customer_address.customer_id = ? LIMIT 1
`

type GetCustomerAddressByAddressAndCustomerParams struct {
	IDAddress  string `json:"id_address"`
	CustomerID string `json:"customer_id"`
}

type GetCustomerAddressByAddressAndCustomerRow struct {
	IDAddress               string              `json:"id_address"`
	CustomerID              string              `json:"customer_id"`
	Address                 string              `json:"address"`
	PhoneNumber             string              `json:"phone_number"`
	CreateDate              sql.NullTime        `json:"create_date"`
	UpdateDate              sql.NullTime        `json:"update_date"`
	CustomerID_2            string              `json:"customer_id_2"`
	Name                    string              `json:"name"`
	Email                   string              `json:"email"`
	Image                   sql.NullString      `json:"image"`
	Dob                     sql.NullTime        `json:"dob"`
	Gender                  NullCustomersGender `json:"gender"`
	AccountID               string              `json:"account_id"`
	CreateDate_2            sql.NullTime        `json:"create_date_2"`
	UpdateDate_2            sql.NullTime        `json:"update_date_2"`
	DeviceRegistrationToken sql.NullString      `json:"device_registration_token"`
}

func (q *Queries) GetCustomerAddressByAddressAndCustomer(ctx context.Context, arg GetCustomerAddressByAddressAndCustomerParams) (GetCustomerAddressByAddressAndCustomerRow, error) {
	row := q.db.QueryRowContext(ctx, getCustomerAddressByAddressAndCustomer, arg.IDAddress, arg.CustomerID)
	var i GetCustomerAddressByAddressAndCustomerRow
	err := row.Scan(
		&i.IDAddress,
		&i.CustomerID,
		&i.Address,
		&i.PhoneNumber,
		&i.CreateDate,
		&i.UpdateDate,
		&i.CustomerID_2,
		&i.Name,
		&i.Email,
		&i.Image,
		&i.Dob,
		&i.Gender,
		&i.AccountID,
		&i.CreateDate_2,
		&i.UpdateDate_2,
		&i.DeviceRegistrationToken,
	)
	return i, err
}

const listCustomerAddresses = `-- name: ListCustomerAddresses :many
SELECT id_address, customer_id, address, phone_number, create_date, update_date FROM customer_address
WHERE customer_id = ?
`

func (q *Queries) ListCustomerAddresses(ctx context.Context, customerID string) ([]CustomerAddress, error) {
	rows, err := q.db.QueryContext(ctx, listCustomerAddresses, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CustomerAddress
	for rows.Next() {
		var i CustomerAddress
		if err := rows.Scan(
			&i.IDAddress,
			&i.CustomerID,
			&i.Address,
			&i.PhoneNumber,
			&i.CreateDate,
			&i.UpdateDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCustomerAddressesPaged = `-- name: ListCustomerAddressesPaged :many
SELECT id_address, customer_id, address, phone_number, create_date, update_date FROM customer_address
WHERE customer_id = ?
ORDER BY id_address
LIMIT ? OFFSET ?
`

type ListCustomerAddressesPagedParams struct {
	CustomerID string `json:"customer_id"`
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
}

func (q *Queries) ListCustomerAddressesPaged(ctx context.Context, arg ListCustomerAddressesPagedParams) ([]CustomerAddress, error) {
	rows, err := q.db.QueryContext(ctx, listCustomerAddressesPaged, arg.CustomerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CustomerAddress
	for rows.Next() {
		var i CustomerAddress
		if err := rows.Scan(
			&i.IDAddress,
			&i.CustomerID,
			&i.Address,
			&i.PhoneNumber,
			&i.CreateDate,
			&i.UpdateDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCustomerAddress = `-- name: UpdateCustomerAddress :exec
UPDATE customer_address
SET address = COALESCE(?, address),
    phone_number = COALESCE(?, phone_number),
    update_date = NOW()
WHERE id_address = ?
`

type UpdateCustomerAddressParams struct {
	Address     sql.NullString `json:"address"`
	PhoneNumber sql.NullString `json:"phone_number"`
	IDAddress   string         `json:"id_address"`
}

func (q *Queries) UpdateCustomerAddress(ctx context.Context, arg UpdateCustomerAddressParams) error {
	_, err := q.db.ExecContext(ctx, updateCustomerAddress, arg.Address, arg.PhoneNumber, arg.IDAddress)
	return err
}
